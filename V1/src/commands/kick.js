const { SlashCommandBuilder, EmbedBuilder } = require('discord.js');
const { kickParticipant, getKickInfo, getPacteKickHistory, unkickParticipant } = require('../services/kickService');
const { getUserByDiscordId, getActiveUserPacte } = require('../services/userManager');
const logger = require('../utils/logger');

module.exports = {
    data: new SlashCommandBuilder()
        .setName('kick')
        .setDescription('Gestion des exclusions de pactes')
        .addSubcommand(subcommand =>
            subcommand
                .setName('player')
                .setDescription('Exclure un joueur du pacte actuel')
                .addUserOption(option =>
                    option
                        .setName('joueur')
                        .setDescription('Joueur √† exclure')
                        .setRequired(true))
                .addStringOption(option =>
                    option
                        .setName('raison')
                        .setDescription('Raison de l\'exclusion')
                        .setRequired(true)
                        .addChoices(
                            { name: 'AFK / Abandon en game', value: 'afk_abandon' },
                            { name: 'Comportement toxique', value: 'toxic_behavior' },
                            { name: 'Troll / Sabotage', value: 'trolling' },
                            { name: 'Inactif trop longtemps', value: 'inactive' },
                            { name: 'Autre (pr√©ciser)', value: 'other' }
                        )))
        .addSubcommand(subcommand =>
            subcommand
                .setName('history')
                .setDescription('Voir l\'historique des exclusions d\'un pacte')
                .addIntegerOption(option =>
                    option
                        .setName('pacte_id')
                        .setDescription('ID du pacte (laisser vide pour le pacte actuel)')
                        .setRequired(false)))
        .addSubcommand(subcommand =>
            subcommand
                .setName('undo')
                .setDescription('Annuler une exclusion (admin seulement)')
                .addUserOption(option =>
                    option
                        .setName('joueur')
                        .setDescription('Joueur √† r√©int√©grer')
                        .setRequired(true))
                .addIntegerOption(option =>
                    option
                        .setName('pacte_id')
                        .setDescription('ID du pacte')
                        .setRequired(true))),

    async execute(interaction) {
        const subcommand = interaction.options.getSubcommand();
        
        try {
            switch (subcommand) {
                case 'player':
                    await handleKickPlayer(interaction);
                    break;
                case 'history':
                    await handleKickHistory(interaction);
                    break;
                case 'undo':
                    await handleUndoKick(interaction);
                    break;
            }
        } catch (error) {
            logger.error('Error in kick command:', error);
            await interaction.reply({
                content: `‚ùå Erreur: ${error.message}`,
                ephemeral: true
            });
        }
    }
};

async function handleKickPlayer(interaction) {
    const targetUser = interaction.options.getUser('joueur');
    const reason = interaction.options.getString('raison');
    
    // V√©rifier que l'utilisateur qui fait la commande est enregistr√©
    const kicker = await getUserByDiscordId(interaction.user.id);
    if (!kicker) {
        return interaction.reply({
            content: '‚ùå Vous devez d\'abord vous enregistrer avec /register',
            ephemeral: true
        });
    }
    
    // V√©rifier que la cible est enregistr√©e
    const target = await getUserByDiscordId(targetUser.id);
    if (!target) {
        return interaction.reply({
            content: '‚ùå Ce joueur n\'est pas enregistr√©.',
            ephemeral: true
        });
    }
    
    // V√©rifier que l'utilisateur a un pacte actif
    const activePacte = await getActiveUserPacte(interaction.user.id);
    if (!activePacte) {
        return interaction.reply({
            content: '‚ùå Vous n\'avez pas de pacte actif.',
            ephemeral: true
        });
    }
    
    // V√©rifier que la cible est dans le m√™me pacte
    const targetActivePacte = await getActiveUserPacte(targetUser.id);
    if (!targetActivePacte || targetActivePacte.id !== activePacte.id) {
        return interaction.reply({
            content: '‚ùå Ce joueur n\'est pas dans votre pacte actif.',
            ephemeral: true
        });
    }
    
    // Ne pas permettre de s'exclure soi-m√™me
    if (targetUser.id === interaction.user.id) {
        return interaction.reply({
            content: '‚ùå Vous ne pouvez pas vous exclure vous-m√™me. Utilisez `/pacte leave` √† la place.',
            ephemeral: true
        });
    }
    
    // Demander une raison personnalis√©e si "other" est s√©lectionn√©
    if (reason === 'other') {
        await interaction.reply({
            content: 'üìù Veuillez pr√©ciser la raison de l\'exclusion dans les 30 secondes :',
            ephemeral: true
        });
        
        const filter = m => m.author.id === interaction.user.id && m.content.length > 0;
        const collector = interaction.channel.createMessageCollector({ filter, time: 30000, max: 1 });
        
        collector.on('collect', async (msg) => {
            const customReason = msg.content.slice(0, 200); // Limiter √† 200 caract√®res
            await processKick(interaction, targetUser, activePacte.id, customReason);
            await msg.delete().catch(() => {}); // Supprimer le message de raison
        });
        
        collector.on('end', collected => {
            if (collected.size === 0) {
                interaction.followUp({ 
                    content: '‚è∞ Temps √©coul√©. Exclusion annul√©e.', 
                    ephemeral: true 
                });
            }
        });
        
        return;
    }
    
    // Mapper les raisons pr√©d√©finies
    const reasonMap = {
        'afk_abandon': 'AFK/Abandon en partie',
        'toxic_behavior': 'Comportement toxique',
        'trolling': 'Troll/Sabotage',
        'inactive': 'Inactif trop longtemps'
    };
    
    const finalReason = reasonMap[reason] || reason;
    await processKick(interaction, targetUser, activePacte.id, finalReason);
}

async function processKick(interaction, targetUser, pacteId, reason) {
    try {
        const result = await kickParticipant(pacteId, targetUser.id, interaction.user.id, reason);
        
        const embed = new EmbedBuilder()
            .setColor(0xFF6B6B)
            .setTitle('‚ö†Ô∏è Joueur exclu du pacte')
            .addFields(
                { name: 'üë§ Joueur exclu', value: result.kickedUser, inline: true },
                { name: 'üëÆ Exclu par', value: result.kickerUser, inline: true },
                { name: 'üìù Raison', value: reason, inline: false },
                { name: 'üí∏ Malus appliqu√©', value: `-${result.malus} points`, inline: true },
                { name: 'üë• Participants restants', value: `${result.remainingParticipants}`, inline: true }
            )
            .setTimestamp();
        
        if (result.pacteStatus === 'failed') {
            embed.addFields({
                name: 'üíÄ Statut du pacte',
                value: 'Le pacte a √©chou√© (pas assez de participants restants)',
                inline: false
            });
        }
        
        await interaction.editReply({ embeds: [embed], ephemeral: false });
        
        // Notifier le joueur exclu
        try {
            const targetUserObj = await interaction.client.users.fetch(targetUser.id);
            await targetUserObj.send({
                content: `‚ö†Ô∏è **Vous avez √©t√© exclu du pacte #${pacteId}**\n` +
                        `**Raison :** ${reason}\n` +
                        `**Malus appliqu√© :** -${result.malus} points\n` +
                        `**Exclu par :** ${result.kickerUser}`
            });
        } catch (error) {
            // Ignore si on ne peut pas envoyer de MP
        }
        
    } catch (error) {
        if (interaction.replied || interaction.deferred) {
            await interaction.followUp({
                content: `‚ùå Erreur lors de l'exclusion : ${error.message}`,
                ephemeral: true
            });
        } else {
            await interaction.reply({
                content: `‚ùå Erreur lors de l'exclusion : ${error.message}`,
                ephemeral: true
            });
        }
    }
}

async function handleKickHistory(interaction) {
    let pacteId = interaction.options.getInteger('pacte_id');
    
    // Si pas d'ID fourni, utiliser le pacte actuel
    if (!pacteId) {
        const activePacte = await getActiveUserPacte(interaction.user.id);
        if (!activePacte) {
            return interaction.reply({
                content: '‚ùå Vous n\'avez pas de pacte actif. Sp√©cifiez un ID de pacte.',
                ephemeral: true
            });
        }
        pacteId = activePacte.id;
    }
    
    const kickHistory = await getPacteKickHistory(pacteId);
    
    if (kickHistory.length === 0) {
        return interaction.reply({
            content: `‚ÑπÔ∏è Aucune exclusion enregistr√©e pour le pacte #${pacteId}.`,
            ephemeral: true
        });
    }
    
    const embed = new EmbedBuilder()
        .setColor(0xFFA500)
        .setTitle(`üìã Historique des exclusions - Pacte #${pacteId}`)
        .setDescription(`Total : ${kickHistory.length} exclusion(s)`)
        .setTimestamp();
    
    // Limiter √† 10 exclusions les plus r√©centes
    const recentKicks = kickHistory.slice(0, 10);
    
    for (const kick of recentKicks) {
        const kickDate = new Date(kick.kicked_at);
        embed.addFields({
            name: `üë§ ${kick.summoner_name}`,
            value: `**Raison :** ${kick.kick_reason}\n` +
                  `**Date :** ${kickDate.toLocaleDateString('fr-FR')} ${kickDate.toLocaleTimeString('fr-FR')}\n` +
                  `**Malus :** ${kick.points_gained} points`,
            inline: true
        });
    }
    
    if (kickHistory.length > 10) {
        embed.setFooter({ text: `... et ${kickHistory.length - 10} autre(s) exclusion(s)` });
    }
    
    await interaction.reply({ embeds: [embed], ephemeral: true });
}

async function handleUndoKick(interaction) {
    // V√©rifier les permissions (uniquement pour les admins ou r√¥les sp√©ciaux)
    const hasAdminRole = interaction.member.permissions.has('ADMINISTRATOR') || 
                        interaction.member.roles.cache.some(role => 
                            ['Admin', 'Mod√©rateur', 'Bot Admin'].includes(role.name)
                        );
    
    if (!hasAdminRole) {
        return interaction.reply({
            content: '‚ùå Seuls les administrateurs peuvent annuler une exclusion.',
            ephemeral: true
        });
    }
    
    const targetUser = interaction.options.getUser('joueur');
    const pacteId = interaction.options.getInteger('pacte_id');
    
    try {
        // V√©rifier que le joueur a bien √©t√© exclu de ce pacte
        const kickInfo = await getKickInfo(pacteId, targetUser.id);
        if (!kickInfo) {
            return interaction.reply({
                content: '‚ùå Ce joueur n\'a pas √©t√© exclu de ce pacte.',
                ephemeral: true
            });
        }
        
        const result = await unkickParticipant(pacteId, targetUser.id, interaction.user.id);
        
        const embed = new EmbedBuilder()
            .setColor(0x00FF00)
            .setTitle('‚úÖ Exclusion annul√©e')
            .addFields(
                { name: 'üë§ Joueur r√©int√©gr√©', value: result.userName, inline: true },
                { name: 'üëÆ Annul√© par', value: result.adminName, inline: true },
                { name: 'üí∞ Points rembours√©s', value: `+${result.refundedPoints}`, inline: true }
            )
            .setTimestamp();
        
        await interaction.reply({ embeds: [embed] });
        
        // Notifier le joueur r√©int√©gr√©
        try {
            const targetUserObj = await interaction.client.users.fetch(targetUser.id);
            await targetUserObj.send({
                content: `‚úÖ **Votre exclusion du pacte #${pacteId} a √©t√© annul√©e**\n` +
                        `**Points rembours√©s :** +${result.refundedPoints}\n` +
                        `**Annul√© par :** ${result.adminName}\n\n` +
                        `Vous pouvez maintenant √©crire "Je signe" pour rejoindre √† nouveau le pacte.`
            });
        } catch (error) {
            // Ignore si on ne peut pas envoyer de MP
        }
        
    } catch (error) {
        await interaction.reply({
            content: `‚ùå Erreur lors de l'annulation : ${error.message}`,
            ephemeral: true
        });
    }
}
